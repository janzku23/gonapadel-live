<script>
  const PROJECT_URL = "https://bxklcpvwtaeklormsdsk.supabase.co";
  const ANON_KEY    = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJ4a2xjcHZ3dGFla2xvcm1zZHNrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMyOTE4MzgsImV4cCI6MjA3ODg2NzgzOH0.bV5-yhGlnHkPBXY_vdirMZjWhPzoiL7OU7txTfexPBA";

  async function fetchTournament(id) {
    const url = `${PROJECT_URL}/rest/v1/mexicano?id=eq.${encodeURIComponent(id)}&select=*`;
    const res = await fetch(url, {
      headers: {
        "apikey": ANON_KEY,
        "Authorization": `Bearer ${ANON_KEY}`
      }
    });
    if (!res.ok) throw new Error("Supabase error: " + res.status);
    const data = await res.json();
    return data[0] || null;
  }

  function getQueryId() {
    const p = new URLSearchParams(window.location.search);
    return p.get("id");
  }

  function render(root, t) {
    if (!t) {
      root.innerHTML = `
        <div class="card error">
          Turnausta ei lÃ¶ytynyt. Varmista ettÃ¤ linkki on oikein.
        </div>
      `;
      return;
    }

    // âœ… NÃ¤mÃ¤ vastaavat sitÃ¤ mitÃ¤ upsert_mexicano kirjoittaa tauluun
    const players = Array.isArray(t.players) ? t.players : [];
    const matches = Array.isArray(t.matches) ? t.matches : [];
    const finished = !!t.isfinished;

    // pointsperround, currentround, totalrounds, courts ovat taulun sarakkeita
    const pointsPerRound = t.pointsperround ?? "-";
    const courts         = t.courts ?? "-";
    const currentRound   = t.currentround ?? 0;
    const totalRounds    = t.totalrounds ?? 0;

    // ðŸ† Pelaajien jÃ¤rjestys â€“ LiveScoreDoc.Player: name, totalPoints, pm50
    const sortedPlayers = [...players].sort(
      (a, b) => (b.totalPoints ?? 0) - (a.totalPoints ?? 0)
    );

    // ðŸ” Etsi uusin pelattu kierros matchien round-kentÃ¤stÃ¤
    let latestRoundNumber = null;
    if (matches.length > 0) {
      latestRoundNumber = matches
        .map(m => m.round ?? 0)
        .reduce((max, v) => v > max ? v : max, 0);
    }
    const latestRoundMatches = latestRoundNumber
      ? matches.filter(m => m.round === latestRoundNumber)
      : [];

    // UI rakentelu
    let html = "";

    // HEADER
    html += `
      <div class="card">
        <div class="title">${t.name || "Padel Mexicano"}</div>
        <div class="subtitle">
          Points / round: <b>${pointsPerRound}</b> &bull;
          Courts: <b>${courts}</b> &bull;
          Players: <b>${players.length}</b>
        </div>
        <div style="margin-bottom: 6px;">
          <span class="badge ${finished ? "green" : "orange"}">
            ${finished ? "Finished" : "Live"}
          </span>
          ${
            totalRounds
              ? `<span class="badge">Rounds (target): ${currentRound}/${totalRounds}</span>`
              : ""
          }
        </div>
        <div class="small">
          This page updates live when scores are entered in the GonaPadel app.
        </div>
      </div>
    `;

    // STANDINGS
    html += `
      <div class="card">
        <div class="title">Standings</div>
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Player</th>
              <th style="text-align:right;">Total</th>
              <th style="text-align:right;">Â±50</th>
            </tr>
          </thead>
          <tbody>
            ${sortedPlayers
              .map((p, idx) => `
                <tr>
                  <td>${idx + 1}</td>
                  <td>${p.name}</td>
                  <td style="text-align:right;">${p.totalPoints ?? 0}</td>
                  <td style="text-align:right;">${p.pm50 ?? ""}</td>
                </tr>
              `)
              .join("")}
          </tbody>
        </table>
      </div>
    `;

    // VIIMEISIN KIERROS (matches + round/court/scoreA/scoreB)
    if (latestRoundMatches.length > 0) {
      html += `
        <div class="card">
          <div class="title">Latest round â€“ #${latestRoundNumber}</div>
          <div class="subtitle">
            ${finished ? "Tournament finished" : "Round in progress / recently played"}
          </div>
      `;

      latestRoundMatches.forEach(m => {
        const aNames = (m.teamA || []).join(" & ");
        const bNames = (m.teamB || []).join(" & ");
        const a = m.scoreA;
        const b = m.scoreB;

        html += `
          <div class="court-card">
            <div class="court-title">
              <span>Court ${ (m.court ?? 0) }</span>
              <span class="small">${typeof a === "number" ? "Finished" : "Playing"}</span>
            </div>
            <div class="small" style="margin-bottom:4px;">
              ${aNames} vs ${bNames}
            </div>
            <div class="small">
              ${
                (typeof a === "number" && typeof b === "number")
                  ? `<b>${a} â€“ ${b}</b>`
                  : "No score yet"
              }
            </div>
          </div>
        `;
      });

      html += `</div>`;
    }

    root.innerHTML = html;
  }

  (async function main() {
    const root = document.getElementById("root");
    const id = getQueryId();
    if (!id) {
      root.innerHTML = `
        <div class="card error">
          No tournament id in URL.<br/>
          Expected: <code>?id=YOUR_UUID</code>
        </div>
      `;
      return;
    }

    try {
      const t = await fetchTournament(id);
      render(root, t);

      // yksinkertainen polling, esim. 10 s vÃ¤lein
      setInterval(async () => {
        try {
          const updated = await fetchTournament(id);
          render(root, updated);
        } catch (e) {
          console.error("Polling error", e);
        }
      }, 10000);
    } catch (e) {
      console.error(e);
      root.innerHTML = `
        <div class="card error">
          Error loading tournament.<br/>
          ${e.message}
        </div>
      `;
    }
  })();
</script>

